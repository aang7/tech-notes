<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<link rel='stylesheet' href='https://cdn.simplecss.org/simple.min.css' />
   <link rel='stylesheet' type='text/css' href='../css/tech-notes-site.css' />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../"> UP </a>
 |
 <a accesskey="H" href="../"> HOME </a>
</div><nil id="nil">
<section id="outline-container-org22bc7e7" class="outline-2">
<h2 id="org22bc7e7">Docker</h2>
<div class="outline-text-2" id="text-org22bc7e7">
<p>
I have to recreate my lost notes about docker.
So in this entry will be the notes below.
The notes are from two courses one from udemy (that I didn&rsquo;t finish) and the other one is on platzi, <a href="https://github.com/platzi/docker/tree/master">here is the gh repo</a> the platzi docker course author provided.
</p>
<div class="org-src-container">
<pre class="src src-shell">
<span class="org-comment-delimiter"># </span><span class="org-comment">helper shell variables</span>
<span class="org-variable-name">WORKING_DIR</span>=$(<span class="org-builtin">pwd</span>)
<span class="org-variable-name">NOTES_EXEC_FOLDER</span>=<span class="org-string">"DockerOut"</span>
<span class="org-variable-name">image_name</span>=postgres
<span class="org-variable-name">volume_name</span>=myvolume
<span class="org-variable-name">path_in_container</span>=/var/lib/postgresql/data
<span class="org-variable-name">path_in_host</span>=$<span class="org-variable-name">WORKING_DIR</span>/$<span class="org-variable-name">NOTES_EXEC_FOLDER</span>
<span class="org-variable-name">custom_image_name</span>=myimage

mkdir $<span class="org-variable-name">NOTES_EXEC_FOLDER</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">BEGIN COMMAND EXAMPLES</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">--list containers processes</span>
docker ps

<span class="org-comment-delimiter"># </span><span class="org-comment">--list all containers (even if they are shutdown)</span>
docker ps -a

<span class="org-comment-delimiter"># </span><span class="org-comment">--pull an image from central hub repository</span>
docker pull $<span class="org-variable-name">image_name</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">--run an image</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">in this case postgres is the &lt;image_name&gt;</span>
docker run $<span class="org-variable-name">image_name</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">--run an image binding ports</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">where 3000 is the port of the container and 3002 is the port of the host</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">this will create a container with an unique id</span>
docker run -p 3002:3000 $<span class="org-variable-name">image_name</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">--run an image with an alias or tag name</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">on this way we can refer to the container not only by its id...</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">but the specied tag name.</span>
docker run --name mydatabase postgres

<span class="org-comment-delimiter"># </span><span class="org-comment">--Volumes</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">creating a volume</span>
docker volume create $<span class="org-variable-name">volume_name</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">if we want to persist data from directory in our host from the container</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">we can use two approaches</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">1. -v for bind-mounts</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">2. --mount to let docker handle a little bit more of security</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">bind-mounts approach example</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">this will reflect all changes in $path_in_container over $path_in_host</span>
docker run -v $<span class="org-variable-name">path_in_host</span>:$<span class="org-variable-name">path_in_container</span> $<span class="org-variable-name">image_name</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">volumes approach example</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">###note: for this you first have to have an existing volume</span>
docker run --name db --mount <span class="org-variable-name">src</span>=$<span class="org-variable-name">volume_name</span>,<span class="org-variable-name">dst</span>=$<span class="org-variable-name">path_in_container</span> $<span class="org-variable-name">image_name</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">--copying files or dirs between host and container</span>
touch prueba.txt <span class="org-comment-delimiter"># </span><span class="org-comment">create file on host workind directory</span>
docker run -d --name copytest postgres tail -f /dev/null <span class="org-comment-delimiter"># </span><span class="org-comment">run a postgres container and add a tail for the container keep running until Ctrl-c</span>
docker exec -it copytest bash <span class="org-comment-delimiter"># </span><span class="org-comment">enter to container</span>
mkdir testing <span class="org-comment-delimiter"># </span><span class="org-comment">create directory in container</span>
docker cp prueba.txt copytest:/testing/test.txt <span class="org-comment-delimiter"># </span><span class="org-comment">copy host file into the container</span>
docker cp copytest:/testing localtesting <span class="org-comment-delimiter"># </span><span class="org-comment">copy directory inside the container to my host</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">###note: with "docker cp" we doesn't need the container to be running.</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">--creating applications</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">build a custom image</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">###note: for this you will need to have a DockerFile on the working directory</span>
docker build -t $<span class="org-variable-name">custom_image_name</span> .
</pre>
</div>
</div>

<div id="outline-container-orgc4383dd" class="outline-3">
<h3 id="orgc4383dd">Volumes</h3>
<div class="outline-text-3" id="text-orgc4383dd">
<p>
Host: Where Docker is installed
Bind Mount: storage the files in host machine in a persistent way (not secure).
Volume: Storage the files on Docker area, where Docker manage the saved data (more secure).
TMPFS Mount: Storage the data temporarely. Data is deleted when container stop running.
</p>


<figure>
<img src="notes.org_imgs/20220915_152926_RMpoRs.png" alt="20220915_152926_RMpoRs.png">

</figure>
</div>
</div>

<div id="outline-container-orgc8e7873" class="outline-3">
<h3 id="orgc8e7873">Developing applications</h3>
<div class="outline-text-3" id="text-orgc8e7873">
<div class="org-src-container">
<pre class="src src-shell"><span class="org-comment-delimiter"># </span><span class="org-comment">this supposed you have an existing Dockerfile</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">on current working directory</span>
docker build -t &lt;image_name&gt; .
</pre>
</div>

<p>
Below we have super basic example of a <code>Dockerfile</code> for a flask application based on an <code>Ubuntu</code> image.
</p>
<div class="org-src-container">
<pre class="src src-shell">FROM Ubuntu
RUN apt-get update &amp;&amp; apt-get &#8211;y install python
RUN pip install flask flask-mysql
COPY . /opt/source-code
ENTRYPOINT <span class="org-variable-name">FLASK_APP</span>=/opt/source-code/app.py flask run 
</pre>
</div>
</div>
</div>


<div id="outline-container-org74e10b0" class="outline-3">
<h3 id="org74e10b0">Networking</h3>
<div class="outline-text-3" id="text-org74e10b0">
<div class="org-src-container">
<pre class="src src-shell">docker network ls
</pre>
</div>

<p>
Above networks are the pre made ones.
</p>

<ul class="org-ul">
<li><b>bridge</b>: old concept, still there for retrocompatibility reasons.</li>
<li><b>host</b>: this one interfaces the host network. It&rsquo;s a representation of the real network of my machine.</li>
<li><b>none</b>: we will use none when whe will want that our container doesn&rsquo;t have any kind of outbound or inbound network on it from the outside of the container.</li>
</ul>

<p>
Creating a network that will have the ability to other containers connect to it.
</p>
<div class="org-src-container">
<pre class="src src-shell">docker network create --attachable &lt;network_name&gt;
</pre>
</div>


<p>
Inspect a network.
</p>
<div class="org-src-container">
<pre class="src src-shell">docker network inspect &lt;network_name&gt;
</pre>
</div>

<p>
Connect a container to a network.
</p>
<div class="org-src-container">
<pre class="src src-shell">docker network connect &lt;network_name&gt; &lt;container_name&gt; 
</pre>
</div>
<p>
When we connect a container to a custom created network, we can then reference a container address by container name. Look at following base example command, where we are using an environment variable inside a running container, you can see under <code>MONGO_URL</code> env variable that in the link we are pointing to <b>db</b>, instead of localhost, <b>db</b> is supposed to be an existing running container that is holding a mongo database.
</p>

<div class="org-src-container">
<pre class="src src-shell">docker run -d -name app -p 3000:3000 --env <span class="org-variable-name">MONGO_URL</span>=mondodb://db:27017/test &lt;image_name&gt; 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgea6451d" class="outline-3">
<h3 id="orgea6451d">Docker compose</h3>
<div class="outline-text-3" id="text-orgea6451d">
<p>
It&rsquo;s tedious to create manually each image and container and then create the network to later connect the desired containers. So for this, docker has something called <code>docker compose</code>, which is a tool to manage containers and their set up between them.
instead of having a <code>Dockerfile</code> docker compose uses a file called <code>docker-compose.yml</code>, in it we declare/define all the services we use for our custom application.
</p>

<p>
Below you can see an example of a docker compose file.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>docker-compose.yml example.</label><pre class="src src-yaml">version: "3.8"

services:
  app:
    image: myapp # if we would like to build an image on the fly use: build: .
    # where the dot after "build:" is the current directory
    environment:
      MONGO_URL: "mongodb://db:27017/test"
    depends_on:
      - db
    ports:
      - "3000:3000"
    volumes:
      - .:/usr/src
      - /usr/src/node_modules # esto ignora la carpeta node_modules para que no se monte
    # command: npx nodemon index.js # with this we can override the CMD declaration upon the Dockerfile of the service we are trying to build/run

  db:
    image: mongo

</pre>
</div>


<p>
then to run the docker compose application:
</p>
<div class="org-src-container">
<pre class="src src-shell">docker-compose up
<span class="org-comment-delimiter"># </span><span class="org-comment">to run in dettach mode just add the -d flag</span>
</pre>
</div>

<p>
We can also use the ps command under docker compose and other utilities like showing the logs.
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-comment-delimiter"># </span><span class="org-comment">list all processes</span>
docker-compose ps

<span class="org-comment-delimiter"># </span><span class="org-comment">show logs</span>
docker-compose logs

<span class="org-comment-delimiter"># </span><span class="org-comment">show logs of an speciic service</span>
docker-compose logs &lt;service_name&gt;

<span class="org-comment-delimiter"># </span><span class="org-comment">execute command on a container or service</span>
docker-compose exec &lt;container_name&gt; &lt;command&gt;

<span class="org-comment-delimiter"># </span><span class="org-comment">delete all generated resources of docker-compose</span>
docker-compose down

<span class="org-comment-delimiter"># </span><span class="org-comment">to build the services defined on the docker-compose.yml file</span>
docker-compose build
<span class="org-comment-delimiter"># </span><span class="org-comment">or you can also build an specific service</span>
docker-compose build &lt;service-name&gt;
</pre>
</div>


<p>
When we are working in collaboration with other team members of a project. We can use a <code>docker-compose.override.yml</code> file to override paramaters defined under the <code>docker-compose.yml</code> base file.
</p>

<div class="org-src-container">
<pre class="src src-yaml">version: "3.8"

services:
  app:
    build: .
    environment:
      ONE_VARIABLE: "some_value"

</pre>
</div>


<p>
some random notes:
</p>
<div class="org-src-container">
<pre class="src src-shell"><span class="org-comment-delimiter"># </span><span class="org-comment">some random commands</span>
docker container prune <span class="org-comment-delimiter"># </span><span class="org-comment">delete all inactive containers</span>
docker rm -f $(docker ps -aq) <span class="org-comment-delimiter"># </span><span class="org-comment">delete all inactive containers</span>
docker network ls <span class="org-comment-delimiter"># </span><span class="org-comment">list networks</span>
docker volume ls <span class="org-comment-delimiter"># </span><span class="org-comment">list volumes</span>
docker image ls <span class="org-comment-delimiter"># </span><span class="org-comment">list images</span>
docker system prune <span class="org-comment-delimiter"># </span><span class="org-comment">delete everything that is not being used</span>
docker run -d --name app --memory 1g platziapp <span class="org-comment-delimiter"># </span><span class="org-comment">limit memory</span>
docker stats <span class="org-comment-delimiter"># </span><span class="org-comment">see how much resources docker uses in the host machine</span>
docker inspect app <span class="org-comment-delimiter"># </span><span class="org-comment">see details about a container, e.g. I can see if the container died due to lack of memory, etc.</span>
</pre>
</div>


<p>
<b>Note</b>: Whenever we have an exit code greater than 128, the exit was caused by an exception or an error not handled within the program.
some commands for <b>stop</b> and/or <b>kill</b> a container.
</p>

<p>
<b>Note</b>: seems that &ldquo;<code>depends_on</code>&rdquo; is now deprecated, instead we have to use <code>healtcheck</code> for more details look <a href="https://stackoverflow.com/questions/52322800/docker-compose-how-to-wait-for-other-service-to-be-ready/64921431#64921431">at this</a> 
</p>

<div class="org-src-container">
<pre class="src src-shell">docker stop &lt;container&gt; <span class="org-comment-delimiter"># </span><span class="org-comment">this will senda SIGTERM signal to the main process of the container</span>
docker kill &lt;container&gt; <span class="org-comment-delimiter"># </span><span class="org-comment">this will send a SIGKILL signal to the main process</span>
</pre>
</div>


<p>
if you want to see the processes of a container.
</p>
<div class="org-src-container">
<pre class="src src-shell">docker exec &lt;container&gt; ps -ef
</pre>
</div>

<p>
There are two forms to define the execution of a container inside the Dockerfile.
</p>

<ol class="org-ol">
<li>exec form</li>
<li><p>
shell form
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>shell form</label><pre class="src src-dockerfile">FROM ubuntu:latest
COPY ["loop.sh", "/"]
CMD /loop.sh
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>exec form</label><pre class="src src-dockerfile">FROM ubuntu:latest
COPY ["loop.sh", "/"]
CMD ["/loop.sh"]
</pre>
</div>

<p>
So as you can see in the third line of the above two code blocks the difference is minimum, in shell form the main process will be bash and the process that is meant to be the main one would be the child of bash, but in the exec form the main process would be the program itself not being a child process of bash.
<b>Note</b>: It is recommended to use the exec form, in this way we can shutdown a container gracefully.
</p>

<p>
For more details on Docker compose look <a href="https://www.educative.io/blog/docker-compose-tutorial">at this</a>.
</p></li>
</ol>
</div>
</div>
</section>
</nil>
<footer id="postamble" class="status">

<div class='footer'>
Copyright © 2022 <a href='mailto:aang.drummer@gmail.com'>Abel Güitian</a> | <a href='https://github.com/aang7/aang7.github.io'>Source</a><br>
Last updated on Oct 07, 2022 using <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.3 (<a href="https://orgmode.org">Org</a> mode 9.1.9) <br>
</div>
</footer>
</body>
</html>
